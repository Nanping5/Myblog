# Go+GORM+Gin+React 个人主页技术文档

## 1. 项目架构

### 技术栈选型
- **后端**: Go 1.21+ + Gin Web框架
- **ORM**: GORM v2
- **数据库**:MySQL
- **前端**: React 18 + TypeScript
- **构建工具**: Vite
- **部署**: Docker + Nginx

### 项目结构
```
personal-website/
├── backend/
│   ├── cmd/
│   │   └── server/
│   │       └── main.go             # 应用入口
│   ├── internal/
│   │   ├── api/
│   │   │   ├── handlers/           # HTTP处理器
│   │   │   ├── middleware/         # 中间件
│   │   │   └── routes/             # 路由定义
│   │   ├── config/                 # 配置管理
│   │   ├── models/                 # 数据模型
│   │   ├── repository/             # 数据访问层
│   │   └── service/                # 业务逻辑层
│   ├── pkg/                        # 公共包
│   ├── migrations/                 # 数据库迁移
│   ├── uploads/                    # 上传文件存储
│   └── go.mod
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/             # React组件
│   │   ├── pages/                  # 页面组件
│   │   ├── hooks/                  # 自定义hooks
│   │   ├── services/               # API服务
│   │   ├── utils/                  # 工具函数
│   │   └── styles/                 # 样式文件
│   ├── package.json
│   └── vite.config.ts
├── docker-compose.yml
└── README.md
```

## 2. 数据库设计

### 用户信息表 (users)
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 文章表 (articles)
```sql
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    summary VARCHAR(500),
    cover_image VARCHAR(255),
    tags TEXT[],
    is_published BOOLEAN DEFAULT false,
    view_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 项目展示表 (projects)
```sql
CREATE TABLE projects (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    github_url VARCHAR(255),
    demo_url VARCHAR(255),
    technologies TEXT[],
    cover_image VARCHAR(255),
    featured BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 访客留言表 (messages)
```sql
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    ip_address INET,
    user_agent TEXT,
    is_read BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 3. 后端API设计

### 认证相关
```
POST   /api/v1/auth/login          # 用户登录
POST   /api/v1/auth/logout         # 用户登出
GET    /api/v1/auth/profile        # 获取用户信息
PUT    /api/v1/auth/profile        # 更新用户信息
```

### 文章管理
```
GET    /api/v1/articles            # 获取文章列表（分页）
GET    /api/v1/articles/:id        # 获取单篇文章
POST   /api/v1/articles            # 创建文章（需认证）
PUT    /api/v1/articles/:id        # 更新文章（需认证）
DELETE /api/v1/articles/:id        # 删除文章（需认证）
```

### 项目管理
```
GET    /api/v1/projects            # 获取项目列表
GET    /api/v1/projects/featured   # 获取精选项目
POST   /api/v1/projects            # 创建项目（需认证）
PUT    /api/v1/projects/:id        # 更新项目（需认证）
DELETE /api/v1/projects/:id        # 删除项目（需认证）
```

### 留言功能
```
POST   /api/v1/messages            # 提交留言
GET    /api/v1/messages            # 获取留言列表（需认证）
PUT    /api/v1/messages/:id/read   # 标记已读（需认证）
```

### 文件上传
```
POST   /api/v1/upload              # 文件上传（需认证）
```

### AI聊天功能
```
GET    /api/v1/ai/models           # 获取可用模型列表
GET    /api/v1/ai/characters       # 获取AI角色列表
POST   /api/v1/ai/chat             # 发送聊天消息
GET    /api/v1/ai/history          # 获取聊天历史
DELETE /api/v1/ai/history          # 清空聊天历史
```

## 4. AI聊天功能设计

### AI角色系统设计

#### AI角色数据库表
```sql
-- AI角色表
CREATE TABLE ai_characters (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,     -- 角色名称
    description TEXT,                      -- 角色描述
    system_prompt TEXT NOT NULL,           -- 系统提示词
    avatar VARCHAR(255),                   -- 角色头像
    personality_tags TEXT[],              -- 性格标签
    greeting_message TEXT,                 -- 打招呼消息
    is_active BOOLEAN DEFAULT true,        -- 是否启用
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- AI模型配置表
CREATE TABLE ai_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,      -- 模型提供商名称 (openai, claude, gemini等)
    display_name VARCHAR(100),             -- 显示名称
    api_endpoint VARCHAR(255),             -- API端点
    model_name VARCHAR(100),               -- 模型名称
    max_tokens INTEGER DEFAULT 4000,       -- 最大令牌数
    temperature DECIMAL(3,2) DEFAULT 0.7,  -- 温度参数
    api_key_encrypted TEXT,                -- 加密的API密钥
    is_active BOOLEAN DEFAULT true,        -- 是否启用
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 聊天记录表
CREATE TABLE chat_messages (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(255) NOT NULL,      -- 会话ID
    user_ip INET,                          -- 用户IP
    character_id INTEGER REFERENCES ai_characters(id), -- AI角色ID
    provider_id INTEGER REFERENCES ai_providers(id),   -- AI提供商ID
    message_type VARCHAR(20) NOT NULL,     -- 消息类型 (user/assistant/system)
    content TEXT NOT NULL,                 -- 消息内容
    token_count INTEGER DEFAULT 0,         -- 消耗的token数量
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引优化
CREATE INDEX idx_chat_messages_session_id ON chat_messages(session_id);
CREATE INDEX idx_chat_messages_created_at ON chat_messages(created_at);
```

#### 默认AI角色定义
```sql
-- 插入默认AI角色
INSERT INTO ai_characters (name, description, system_prompt, personality_tags, greeting_message) VALUES
('智能助手', '专业的技术顾问，能够帮助你解决编程和技术问题',
'你是一个专业的技术顾问AI助手，名字叫"小智"。你擅长编程、系统架构、技术选型等各种技术问题。请用专业、友好、耐心的语气回答问题。当你不确定答案时，会诚实地告诉用户。',
'["专业", "友好", "耐心", "技术达人"]', '你好！我是小智，很高兴为你服务！有什么技术问题需要我帮忙吗？'),

('创意伙伴', '富有创造力的AI伙伴，帮助你进行创意思考和头脑风暴',
'你是一个富有创造力的AI伙伴，名字叫"灵感"。你擅长创意写作、头脑风暴、产品设计等创意工作。请用活泼、富有想象力的语气回应，鼓励用户发挥创造力。',
'["创意", "活泼", "想象力", "鼓励"]', '嘿！我是灵感，让我们一起创造些有趣的东西吧！'),

('生活导师', '温暖贴心的生活顾问，提供生活建议和情感支持',
'你是一个温暖贴心的生活顾问AI，名字叫"暖心"。你擅长提供生活建议、情感支持、时间管理等方面的帮助。请用温暖、理解、关怀的语气回应用户。',
'["温暖", "关怀", "理解", "贴心"]', '你好呀，我是暖心，有什么烦心事或者需要建议的地方吗？'),

('幽默大师', '风趣幽默的AI伙伴，让聊天充满欢乐',
'你是一个风趣幽默的AI伙伴，名字叫"乐天"。你擅长用幽默的方式回答问题，适当地加入笑话和有趣的梗。但请注意分寸，不要过度幽默而显得不专业。',
'["幽默", "风趣", "搞笑", "乐观"]', '哈哈！我是乐天，准备好迎接欢乐了吗？尽管问吧！');
```

### 后端实现

#### 1. 统一的AI接口抽象
```go
// internal/service/ai/interface.go
package ai

import "context"

// ChatMessage 聊天消息结构
type ChatMessage struct {
    Role    string `json:"role"`    // user, assistant, system
    Content string `json:"content"`
}

// ChatCompletionRequest 聊天完成请求
type ChatCompletionRequest struct {
    Model       string        `json:"model"`
    Messages    []ChatMessage `json:"messages"`
    Temperature float32       `json:"temperature,omitempty"`
    MaxTokens   int          `json:"max_tokens,omitempty"`
    Stream      bool         `json:"stream,omitempty"`
}

// ChatCompletionResponse 聊天完成响应
type ChatCompletionResponse struct {
    ID      string        `json:"id"`
    Object  string        `json:"object"`
    Model   string        `json:"model"`
    Choices []ChatChoice  `json:"choices"`
    Usage   ChatUsage     `json:"usage"`
}

// ChatChoice 聊天选择
type ChatChoice struct {
    Index        int          `json:"index"`
    Message      ChatMessage  `json:"message"`
    FinishReason string       `json:"finish_reason"`
}

// ChatUsage Token使用情况
type ChatUsage struct {
    PromptTokens     int `json:"prompt_tokens"`
    CompletionTokens int `json:"completion_tokens"`
    TotalTokens      int `json:"total_tokens"`
}

// AIProvider AI提供商接口
type AIProvider interface {
    ChatCompletion(ctx context.Context, req *ChatCompletionRequest) (*ChatCompletionResponse, error)
    GetModelName() string
    GetProviderName() string
}
```

#### 2. OpenAI实现
```go
// internal/service/ai/openai.go
package ai

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net/http"
)

type OpenAIProvider struct {
    apiURL  string
    apiKey  string
    model   string
    client  *http.Client
}

func NewOpenAIProvider(apiURL, apiKey, model string) *OpenAIProvider {
    return &OpenAIProvider{
        apiURL: apiURL,
        apiKey: apiKey,
        model:  model,
        client: &http.Client{},
    }
}

func (p *OpenAIProvider) ChatCompletion(ctx context.Context, req *ChatCompletionRequest) (*ChatCompletionResponse, error) {
    req.Model = p.model

    jsonReq, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf("marshal request failed: %w", err)
    }

    httpReq, err := http.NewRequestWithContext(ctx, "POST", p.apiURL+"/chat/completions", bytes.NewBuffer(jsonReq))
    if err != nil {
        return nil, fmt.Errorf("create request failed: %w", err)
    }

    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("Authorization", "Bearer "+p.apiKey)

    resp, err := p.client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API error: %d", resp.StatusCode)
    }

    var result ChatCompletionResponse
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, fmt.Errorf("decode response failed: %w", err)
    }

    return &result, nil
}

func (p *OpenAIProvider) GetModelName() string {
    return p.model
}

func (p *OpenAIProvider) GetProviderName() string {
    return "openai"
}
```

#### 3. Claude实现
```go
// internal/service/ai/claude.go
package ai

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "net/http"
)

type ClaudeProvider struct {
    apiURL  string
    apiKey  string
    model   string
    client  *http.Client
}

func NewClaudeProvider(apiURL, apiKey, model string) *ClaudeProvider {
    return &ClaudeProvider{
        apiURL: apiURL,
        apiKey: apiKey,
        model:  model,
        client: &http.Client{},
    }
}

func (p *ClaudeProvider) ChatCompletion(ctx context.Context, req *ChatCompletionRequest) (*ChatCompletionResponse, error) {
    // Claude的请求格式转换
    claudeReq := struct {
        Model       string        `json:"model"`
        MaxTokens   int          `json:"max_tokens"`
        Messages    []ChatMessage `json:"messages"`
        Temperature float32       `json:"temperature,omitempty"`
        Stream      bool         `json:"stream,omitempty"`
    }{
        Model:       p.model,
        MaxTokens:   req.MaxTokens,
        Messages:    req.Messages,
        Temperature: req.Temperature,
        Stream:      req.Stream,
    }

    jsonReq, err := json.Marshal(claudeReq)
    if err != nil {
        return nil, fmt.Errorf("marshal request failed: %w", err)
    }

    httpReq, err := http.NewRequestWithContext(ctx, "POST", p.apiURL+"/v1/messages", bytes.NewBuffer(jsonReq))
    if err != nil {
        return nil, fmt.Errorf("create request failed: %w", err)
    }

    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("x-api-key", p.apiKey)
    httpReq.Header.Set("anthropic-version", "2023-06-01")

    resp, err := p.client.Do(httpReq)
    if err != nil {
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API error: %d", resp.StatusCode)
    }

    // Claude响应格式转换为统一格式
    var claudeResp struct {
        ID    string `json:"id"`
        Model string `json:"model"`
        Usage struct {
            InputTokens  int `json:"input_tokens"`
            OutputTokens int `json:"output_tokens"`
        } `json:"usage"`
        Content []struct {
            Type string `json:"type"`
            Text string `json:"text"`
        } `json:"content"`
    }

    if err := json.NewDecoder(resp.Body).Decode(&claudeResp); err != nil {
        return nil, fmt.Errorf("decode response failed: %w", err)
    }

    // 转换为统一响应格式
    response := &ChatCompletionResponse{
        ID:     claudeResp.ID,
        Object: "chat.completion",
        Model:  claudeResp.Model,
        Usage: ChatUsage{
            PromptTokens:     claudeResp.Usage.InputTokens,
            CompletionTokens: claudeResp.Usage.OutputTokens,
            TotalTokens:      claudeResp.Usage.InputTokens + claudeResp.Usage.OutputTokens,
        },
    }

    if len(claudeResp.Content) > 0 {
        response.Choices = []ChatChoice{
            {
                Index: 0,
                Message: ChatMessage{
                    Role:    "assistant",
                    Content: claudeResp.Content[0].Text,
                },
                FinishReason: "stop",
            },
        }
    }

    return response, nil
}

func (p *ClaudeProvider) GetModelName() string {
    return p.model
}

func (p *ClaudeProvider) GetProviderName() string {
    return "claude"
}
```

#### 4. AI服务管理器
```go
// internal/service/ai/manager.go
package ai

import (
    "context"
    "fmt"
)

type AIManager struct {
    providers map[string]AIProvider
    defaultProvider string
}

func NewAIManager() *AIManager {
    return &AIManager{
        providers: make(map[string]AIProvider),
    }
}

func (m *AIManager) RegisterProvider(name string, provider AIProvider) {
    m.providers[name] = provider
    if m.defaultProvider == "" {
        m.defaultProvider = name
    }
}

func (m *AIManager) SetDefaultProvider(name string) error {
    if _, exists := m.providers[name]; !exists {
        return fmt.Errorf("provider %s not found", name)
    }
    m.defaultProvider = name
    return nil
}

func (m *AIManager) GetProvider(name string) (AIProvider, error) {
    if name == "" {
        name = m.defaultProvider
    }

    provider, exists := m.providers[name]
    if !exists {
        return nil, fmt.Errorf("provider %s not found", name)
    }

    return provider, nil
}

func (m *AIManager) ChatCompletion(ctx context.Context, providerName string, req *ChatCompletionRequest) (*ChatCompletionResponse, error) {
    provider, err := m.GetProvider(providerName)
    if err != nil {
        return nil, err
    }

    return provider.ChatCompletion(ctx, req)
}
```

#### 5. 聊天处理器
```go
// internal/api/handlers/ai.go
package handlers

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    "your-project/internal/service/ai"
)

type AIHandler struct {
    aiManager *ai.AIManager
    // 其他依赖...
}

func NewAIHandler(aiManager *ai.AIManager) *AIHandler {
    return &AIHandler{
        aiManager: aiManager,
    }
}

type ChatRequest struct {
    Message     string `json:"message" binding:"required"`
    CharacterID int64  `json:"character_id"`
    Provider    string `json:"provider"`
    SessionID   string `json:"session_id"`
}

type ChatResponse struct {
    Reply      string `json:"reply"`
    SessionID  string `json:"session_id"`
    Model      string `json:"model"`
    TokenUsage struct {
        Prompt     int `json:"prompt"`
        Completion int `json:"completion"`
        Total      int `json:"total"`
    } `json:"token_usage"`
}

// Chat 处理聊天请求
func (h *AIHandler) Chat(c *gin.Context) {
    var req ChatRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    // 获取AI角色信息
    character, err := h.getCharacter(req.CharacterID)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid character"})
        return
    }

    // 构建对话历史（从数据库获取）
    messages, err := h.getChatHistory(req.SessionID, character.ID)
    if err != nil {
        messages = []ai.ChatMessage{}
    }

    // 添加系统提示词
    systemMessage := ai.ChatMessage{
        Role:    "system",
        Content: character.SystemPrompt,
    }

    // 添加用户消息
    userMessage := ai.ChatMessage{
        Role:    "user",
        Content: req.Message,
    }

    // 构建完整消息列表
    allMessages := []ai.ChatMessage{systemMessage}
    allMessages = append(allMessages, messages...)
    allMessages = append(allMessages, userMessage)

    // 调用AI
    aiReq := &ai.ChatCompletionRequest{
        Messages:    allMessages,
        Temperature: 0.7,
        MaxTokens:   2000,
    }

    resp, err := h.aiManager.ChatCompletion(c.Request.Context(), req.Provider, aiReq)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    if len(resp.Choices) == 0 {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "No response from AI"})
        return
    }

    // 保存对话记录
    h.saveChatMessages(req.SessionID, character.ID, req.Provider, messages, resp)

    // 返回响应
    response := ChatResponse{
        Reply:     resp.Choices[0].Message.Content,
        SessionID: req.SessionID,
        Model:     resp.Model,
    }

    response.TokenUsage.Prompt = resp.Usage.PromptTokens
    response.TokenUsage.Completion = resp.Usage.CompletionTokens
    response.TokenUsage.Total = resp.Usage.TotalTokens

    c.JSON(http.StatusOK, response)
}

// GetModels 获取可用模型列表
func (h *AIHandler) GetModels(c *gin.Context) {
    // 返回已配置的AI模型列表
    models := []map[string]interface{}{
        {"name": "gpt-3.5-turbo", "provider": "openai", "display_name": "GPT-3.5 Turbo"},
        {"name": "gpt-4", "provider": "openai", "display_name": "GPT-4"},
        {"name": "claude-3-sonnet", "provider": "claude", "display_name": "Claude 3 Sonnet"},
        {"name": "claude-3-opus", "provider": "claude", "display_name": "Claude 3 Opus"},
    }

    c.JSON(http.StatusOK, gin.H{"models": models})
}

// GetCharacters 获取AI角色列表
func (h *AIHandler) GetCharacters(c *gin.Context) {
    // 从数据库获取AI角色列表
    characters, err := h.getAllCharacters()
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }

    c.JSON(http.StatusOK, gin.H{"characters": characters})
}
```

### 前端实现

#### 1. 聊天组件
```typescript
// src/components/Chat/ChatInterface.tsx
import React, { useState, useEffect, useRef } from 'react';
import { Send, Bot, User, Settings } from 'lucide-react';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

interface AICharacter {
  id: number;
  name: string;
  description: string;
  avatar: string;
  greeting_message: string;
}

interface AIModel {
  name: string;
  provider: string;
  display_name: string;
}

export const ChatInterface: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [sessionId, setSessionId] = useState('');
  const [selectedCharacter, setSelectedCharacter] = useState<AICharacter | null>(null);
  const [selectedModel, setSelectedModel] = useState<AIModel | null>(null);
  const [characters, setCharacters] = useState<AICharacter[]>([]);
  const [models, setModels] = useState<AIModel[]>([]);
  const [showSettings, setShowSettings] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // 初始化
  useEffect(() => {
    // 生成会话ID
    setSessionId(`session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);

    // 加载角色和模型
    fetchCharacters();
    fetchModels();
  }, []);

  // 自动滚动到底部
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const fetchCharacters = async () => {
    try {
      const response = await fetch('/api/v1/ai/characters');
      const data = await response.json();
      setCharacters(data.characters);
      if (data.characters.length > 0) {
        setSelectedCharacter(data.characters[0]);
      }
    } catch (error) {
      console.error('Failed to fetch characters:', error);
    }
  };

  const fetchModels = async () => {
    try {
      const response = await fetch('/api/v1/ai/models');
      const data = await response.json();
      setModels(data.models);
      if (data.models.length > 0) {
        setSelectedModel(data.models[0]);
      }
    } catch (error) {
      console.error('Failed to fetch models:', error);
    }
  };

  const handleSend = async () => {
    if (!input.trim() || isLoading || !selectedCharacter || !selectedModel) return;

    const userMessage: Message = {
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/v1/ai/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: input,
          character_id: selectedCharacter.id,
          provider: selectedModel.provider,
          session_id: sessionId,
        }),
      });

      const data = await response.json();

      const assistantMessage: Message = {
        role: 'assistant',
        content: data.reply,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Failed to send message:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  return (
    <div className="flex h-screen bg-gray-50">
      {/* 聊天主界面 */}
      <div className="flex-1 flex flex-col">
        {/* 头部 */}
        <div className="bg-white shadow-sm border-b px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <Bot className="w-8 h-8 text-blue-500" />
              <div>
                <h1 className="text-xl font-semibold">AI 聊天助手</h1>
                {selectedCharacter && (
                  <p className="text-sm text-gray-500">
                    当前角色: {selectedCharacter.name}
                  </p>
                )}
              </div>
            </div>
            <button
              onClick={() => setShowSettings(!showSettings)}
              className="p-2 hover:bg-gray-100 rounded-lg"
            >
              <Settings className="w-5 h-5" />
            </button>
          </div>
        </div>

        {/* 消息列表 */}
        <div className="flex-1 overflow-y-auto px-6 py-4">
          {messages.length === 0 && selectedCharacter && (
            <div className="text-center text-gray-500 mt-8">
              <Bot className="w-12 h-12 mx-auto mb-4 text-gray-300" />
              <p>{selectedCharacter.greeting_message}</p>
            </div>
          )}

          {messages.map((message, index) => (
            <div
              key={index}
              className={`flex mb-4 ${
                message.role === 'user' ? 'justify-end' : 'justify-start'
              }`}
            >
              <div
                className={`flex items-start space-x-3 max-w-2xl ${
                  message.role === 'user' ? 'flex-row-reverse space-x-reverse' : ''
                }`}
              >
                <div className="flex-shrink-0">
                  {message.role === 'user' ? (
                    <div className="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                      <User className="w-5 h-5 text-white" />
                    </div>
                  ) : (
                    <div className="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
                      <Bot className="w-5 h-5 text-white" />
                    </div>
                  )}
                </div>
                <div
                  className={`px-4 py-2 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white'
                      : 'bg-white border'
                  }`}
                >
                  <p className="whitespace-pre-wrap">{message.content}</p>
                  <p
                    className={`text-xs mt-1 ${
                      message.role === 'user' ? 'text-blue-100' : 'text-gray-500'
                    }`}
                  >
                    {message.timestamp.toLocaleTimeString()}
                  </p>
                </div>
              </div>
            </div>
          ))}

          {isLoading && (
            <div className="flex justify-start mb-4">
              <div className="flex items-start space-x-3">
                <div className="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
                  <Bot className="w-5 h-5 text-white" />
                </div>
                <div className="px-4 py-2 rounded-lg bg-white border">
                  <div className="flex space-x-2">
                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                  </div>
                </div>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>

        {/* 输入框 */}
        <div className="bg-white border-t px-6 py-4">
          <div className="flex space-x-4">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="输入消息..."
              className="flex-1 px-4 py-2 border rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
              rows={2}
              disabled={isLoading}
            />
            <button
              onClick={handleSend}
              disabled={!input.trim() || isLoading}
              className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
            >
              <Send className="w-5 h-5" />
            </button>
          </div>
        </div>
      </div>

      {/* 设置面板 */}
      {showSettings && (
        <div className="w-80 bg-white border-l p-6">
          <h2 className="text-lg font-semibold mb-4">聊天设置</h2>

          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              选择AI角色
            </label>
            <select
              value={selectedCharacter?.id || ''}
              onChange={(e) => {
                const character = characters.find(c => c.id === parseInt(e.target.value));
                setSelectedCharacter(character || null);
              }}
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              {characters.map(character => (
                <option key={character.id} value={character.id}>
                  {character.name}
                </option>
              ))}
            </select>
            {selectedCharacter && (
              <p className="text-xs text-gray-500 mt-1">{selectedCharacter.description}</p>
            )}
          </div>

          <div className="mb-6">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              选择AI模型
            </label>
            <select
              value={selectedModel?.name || ''}
              onChange={(e) => {
                const model = models.find(m => m.name === e.target.value);
                setSelectedModel(model || null);
              }}
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              {models.map(model => (
                <option key={model.name} value={model.name}>
                  {model.display_name}
                </option>
              ))}
            </select>
          </div>

          <button
            onClick={() => {
              setMessages([]);
              setSessionId(`session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`);
            }}
            className="w-full px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200"
          >
            清空对话历史
          </button>
        </div>
      )}
    </div>
  );
};
```

## 5. GORM模型定义

```go
// models/user.go
type User struct {
    ID           uint      `gorm:"primaryKey" json:"id"`
    Username     string    `gorm:"unique;not null" json:"username"`
    Email        string    `gorm:"unique;not null" json:"email"`
    PasswordHash string    `gorm:"not null" json:"-"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}

// models/article.go
type Article struct {
    ID          uint      `gorm:"primaryKey" json:"id"`
    Title       string    `gorm:"not null" json:"title"`
    Content     string    `gorm:"type:text" json:"content"`
    Summary     string    `json:"summary"`
    CoverImage  string    `json:"cover_image"`
    Tags        pq.StringArray `gorm:"type:text[]" json:"tags"`
    IsPublished bool      `gorm:"default:false" json:"is_published"`
    ViewCount   int       `gorm:"default:0" json:"view_count"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// models/project.go
type Project struct {
    ID           uint      `gorm:"primaryKey" json:"id"`
    Name         string    `gorm:"not null" json:"name"`
    Description  string    `json:"description"`
    GithubURL    string    `json:"github_url"`
    DemoURL      string    `json:"demo_url"`
    Technologies pq.StringArray `gorm:"type:text[]" json:"technologies"`
    CoverImage   string    `json:"cover_image"`
    Featured     bool      `gorm:"default:false" json:"featured"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}

// models/message.go
type Message struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Name      string    `gorm:"not null" json:"name"`
    Email     string    `gorm:"not null" json:"email"`
    Content   string    `gorm:"not null;type:text" json:"content"`
    IPAddress string    `gorm:"type:inet" json:"ip_address"`
    UserAgent string    `gorm:"type:text" json:"user_agent"`
    IsRead    bool      `gorm:"default:false" json:"is_read"`
    CreatedAt time.Time `json:"created_at"`
}

// models/ai_character.go
type AICharacter struct {
    ID              uint      `gorm:"primaryKey" json:"id"`
    Name            string    `gorm:"unique;not null" json:"name"`
    Description     string    `gorm:"type:text" json:"description"`
    SystemPrompt    string    `gorm:"type:text;not null" json:"system_prompt"`
    Avatar          string    `json:"avatar"`
    PersonalityTags pq.StringArray `gorm:"type:text[]" json:"personality_tags"`
    GreetingMessage string    `gorm:"type:text" json:"greeting_message"`
    IsActive        bool      `gorm:"default:true" json:"is_active"`
    CreatedAt       time.Time `json:"created_at"`
    UpdatedAt       time.Time `json:"updated_at"`
}

// models/ai_provider.go
type AIProvider struct {
    ID              uint      `gorm:"primaryKey" json:"id"`
    Name            string    `gorm:"unique;not null" json:"name"`
    DisplayName     string    `json:"display_name"`
    APIEndpoint     string    `json:"api_endpoint"`
    ModelName       string    `json:"model_name"`
    MaxTokens       int       `gorm:"default:4000" json:"max_tokens"`
    Temperature     float32   `gorm:"default:0.7" json:"temperature"`
    APIKeyEncrypted string    `gorm:"type:text" json:"-"`
    IsActive        bool      `gorm:"default:true" json:"is_active"`
    CreatedAt       time.Time `json:"created_at"`
    UpdatedAt       time.Time `json:"updated_at"`
}

// models/chat_message.go
type ChatMessage struct {
    ID         uint      `gorm:"primaryKey" json:"id"`
    SessionID  string    `gorm:"not null" json:"session_id"`
    UserIP     string    `gorm:"type:inet" json:"user_ip"`
    CharacterID uint    `json:"character_id"`
    ProviderID uint     `json:"provider_id"`
    MessageType string  `gorm:"not null" json:"message_type"`
    Content    string    `gorm:"type:text;not null" json:"content"`
    TokenCount int       `gorm:"default:0" json:"token_count"`
    CreatedAt  time.Time `json:"created_at"`

    // 关联
    Character AICharacter `gorm:"foreignKey:CharacterID" json:"character,omitempty"`
    Provider AIProvider   `gorm:"foreignKey:ProviderID" json:"provider,omitempty"`
}
```

## 5. Gin路由配置示例

```go
// routes/routes.go
func SetupRoutes(r *gin.Engine) {
    // 中间件
    r.Use(cors.Default())
    r.Use(gin.Logger())
    r.Use(gin.Recovery())

    // 静态文件服务
    r.Static("/uploads", "./uploads")

    // API v1
    v1 := r.Group("/api/v1")
    {
        // 认证
        auth := v1.Group("/auth")
        {
            auth.POST("/login", handlers.Login)
            auth.POST("/logout", handlers.Logout)
            auth.GET("/profile", authMiddleware(), handlers.GetProfile)
            auth.PUT("/profile", authMiddleware(), handlers.UpdateProfile)
        }

        // 文章
        articles := v1.Group("/articles")
        {
            articles.GET("", handlers.GetArticles)
            articles.GET("/:id", handlers.GetArticle)
            articles.POST("", authMiddleware(), handlers.CreateArticle)
            articles.PUT("/:id", authMiddleware(), handlers.UpdateArticle)
            articles.DELETE("/:id", authMiddleware(), handlers.DeleteArticle)
        }

        // 项目
        projects := v1.Group("/projects")
        {
            projects.GET("", handlers.GetProjects)
            projects.GET("/featured", handlers.GetFeaturedProjects)
            projects.POST("", authMiddleware(), handlers.CreateProject)
            projects.PUT("/:id", authMiddleware(), handlers.UpdateProject)
            projects.DELETE("/:id", authMiddleware(), handlers.DeleteProject)
        }

        // 留言
        messages := v1.Group("/messages")
        {
            messages.POST("", handlers.CreateMessage)
            messages.GET("", authMiddleware(), handlers.GetMessages)
            messages.PUT("/:id/read", authMiddleware(), handlers.MarkMessageAsRead)
        }

        // 文件上传
        v1.POST("/upload", authMiddleware(), handlers.UploadFile)

        // AI聊天功能
        ai := v1.Group("/ai")
        {
            ai.GET("/models", handlers.GetModels)
            ai.GET("/characters", handlers.GetCharacters)
            ai.POST("/chat", handlers.Chat)
            ai.GET("/history/:sessionId", handlers.GetChatHistory)
            ai.DELETE("/history/:sessionId", handlers.ClearChatHistory)
        }
    }
}
```

## 6. React前端架构

### 组件结构
```typescript
// types/index.ts
export interface Article {
  id: number;
  title: string;
  content: string;
  summary: string;
  cover_image: string;
  tags: string[];
  is_published: boolean;
  view_count: number;
  created_at: string;
  updated_at: string;
}

export interface Project {
  id: number;
  name: string;
  description: string;
  github_url: string;
  demo_url: string;
  technologies: string[];
  cover_image: string;
  featured: boolean;
  created_at: string;
  updated_at: string;
}

export interface Message {
  id: number;
  name: string;
  email: string;
  content: string;
  ip_address: string;
  user_agent: string;
  is_read: boolean;
  created_at: string;
}

export interface AICharacter {
  id: number;
  name: string;
  description: string;
  avatar: string;
  personality_tags: string[];
  greeting_message: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface AIProvider {
  id: number;
  name: string;
  display_name: string;
  model_name: string;
  is_active: boolean;
}

export interface ChatMessage {
  id: number;
  session_id: string;
  character_id: number;
  provider_id: number;
  message_type: 'user' | 'assistant' | 'system';
  content: string;
  token_count: number;
  created_at: string;
  character?: AICharacter;
  provider?: AIProvider;
}
```

### API服务封装
```typescript
// services/api.ts
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080/api/v1';

class ApiService {
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.statusText}`);
    }

    return response.json();
  }

  // 文章相关
  async getArticles(page = 1, limit = 10) {
    return this.request(`/articles?page=${page}&limit=${limit}`);
  }

  async getArticle(id: number) {
    return this.request(`/articles/${id}`);
  }

  async createArticle(article: Partial<Article>) {
    return this.request('/articles', {
      method: 'POST',
      body: JSON.stringify(article),
    });
  }

  // 项目相关
  async getProjects() {
    return this.request('/projects');
  }

  async getFeaturedProjects() {
    return this.request('/projects/featured');
  }

  // 留言相关
  async createMessage(message: Omit<Message, 'id' | 'is_read' | 'created_at'>) {
    return this.request('/messages', {
      method: 'POST',
      body: JSON.stringify(message),
    });
  }

  // AI聊天相关
  async getAIModels() {
    return this.request('/ai/models');
  }

  async getAICharacters() {
    return this.request('/ai/characters');
  }

  async sendChatMessage(data: {
    message: string;
    character_id: number;
    provider: string;
    session_id: string;
  }) {
    return this.request('/ai/chat', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async getChatHistory(sessionId: string) {
    return this.request(`/ai/history/${sessionId}`);
  }

  async clearChatHistory(sessionId: string) {
    return this.request(`/ai/history/${sessionId}`, {
      method: 'DELETE',
    });
  }
}

export const apiService = new ApiService();
```

## 7. 部署配置

### Docker Compose配置
```yaml
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: personal_website
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: your_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: your_password
      DB_NAME: personal_website
    depends_on:
      - db
    volumes:
      - ./uploads:/app/uploads

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

volumes:
  postgres_data:
```

### 后端Dockerfile
```dockerfile
# backend/Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o server cmd/server/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/server .
COPY --from=builder /app/migrations ./migrations

EXPOSE 8080
CMD ["./server"]
```

### 前端Dockerfile
```dockerfile
# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## 8. AI聊天功能开发步骤

### 1. 后端集成大模型SDK
```bash
# 安装必要的Go依赖
go get -u github.com/gin-gonic/gin
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql
go get -u golang.org/x/crypto/bcrypt
go get -u github.com/golang-jwt/jwt/v4
go get -u github.com/lib/pq  # PostgreSQL数组类型支持

# OpenAI SDK（可选，也可以直接调用API）
go get -u github.com/sashabaranov/go-openai

# 加密库（用于存储API密钥）
go get -u golang.org/x/crypto/aes
```

### 2. 配置AI提供商
在环境变量中配置API密钥：
```bash
# backend/.env
# OpenAI配置
OPENAI_API_KEY=your_openai_api_key
OPENAI_BASE_URL=https://api.openai.com/v1

# Claude配置
CLAUDE_API_KEY=your_claude_api_key
CLAUDE_BASE_URL=https://api.anthropic.com

# Gemini配置
GEMINI_API_KEY=your_gemini_api_key
GEMINI_BASE_URL=https://generativelanguage.googleapis.com/v1

# 通用配置
AI_DEFAULT_MODEL=gpt-3.5-turbo
AI_MAX_TOKENS=4000
AI_TEMPERATURE=0.7
```

### 3. 初始化AI服务
在main.go中初始化AI管理器：
```go
// cmd/server/main.go
func main() {
    // ... 其他初始化代码

    // 初始化AI管理器
    aiManager := ai.NewAIManager()

    // 注册OpenAI
    if openaiKey := os.Getenv("OPENAI_API_KEY"); openaiKey != "" {
        openaiProvider := ai.NewOpenAIProvider(
            os.Getenv("OPENAI_BASE_URL"),
            openaiKey,
            os.Getenv("AI_DEFAULT_MODEL"),
        )
        aiManager.RegisterProvider("openai", openaiProvider)
    }

    // 注册Claude
    if claudeKey := os.Getenv("CLAUDE_API_KEY"); claudeKey != "" {
        claudeProvider := ai.NewClaudeProvider(
            os.Getenv("CLAUDE_BASE_URL"),
            claudeKey,
            "claude-3-sonnet-20240229",
        )
        aiManager.RegisterProvider("claude", claudeProvider)
    }

    // 设置默认提供商
    aiManager.SetDefaultProvider("openai")

    // 创建AI处理器
    aiHandler := handlers.NewAIHandler(aiManager)

    // 设置路由
    r := gin.Default()
    // ... 其他路由
    setupAIRoutes(r, aiHandler)

    // ... 启动服务器
}
```

### 4. 数据库迁移
创建数据库迁移文件，插入默认AI角色：
```sql
-- migrations/001_create_ai_tables.sql
-- AI角色和聊天表已在上面定义

-- 插入默认AI角色
INSERT INTO ai_characters (name, description, system_prompt, personality_tags, greeting_message, created_at, updated_at) VALUES
('智能助手', '专业的技术顾问，能够帮助你解决编程和技术问题', '你是一个专业的技术顾问AI助手，名字叫"小智"。你擅长编程、系统架构、技术选型等各种技术问题。请用专业、友好、耐心的语气回答问题。当你不确定答案时，会诚实地告诉用户。', '["专业", "友好", "耐心", "技术达人"]', '你好！我是小智，很高兴为你服务！有什么技术问题需要我帮忙吗？', NOW(), NOW()),
('创意伙伴', '富有创造力的AI伙伴，帮助你进行创意思考和头脑风暴', '你是一个富有创造力的AI伙伴，名字叫"灵感"。你擅长创意写作、头脑风暴、产品设计等创意工作。请用活泼、富有想象力的语气回应，鼓励用户发挥创造力。', '["创意", "活泼", "想象力", "鼓励"]', '嘿！我是灵感，让我们一起创造些有趣的东西吧！', NOW(), NOW()),
('生活导师', '温暖贴心的生活顾问，提供生活建议和情感支持', '你是一个温暖贴心的生活顾问AI，名字叫"暖心"。你擅长提供生活建议、情感支持、时间管理等方面的帮助。请用温暖、理解、关怀的语气回应用户。', '["温暖", "关怀", "理解", "贴心"]', '你好呀，我是暖心，有什么烦心事或者需要建议的地方吗？', NOW(), NOW()),
('幽默大师', '风趣幽默的AI伙伴，让聊天充满欢乐', '你是一个风趣幽默的AI伙伴，名字叫"乐天"。你擅长用幽默的方式回答问题，适当地加入笑话和有趣的梗。但请注意分寸，不要过度幽默而显得不专业。', '["幽默", "风趣", "搞笑", "乐观"]', '哈哈！我是乐天，准备好迎接欢乐了吗？尽管问吧！', NOW(), NOW());
```

## 9. 开发指南

### 后端开发步骤
1. 初始化Go模块：`go mod init personal-website`
2. 安装依赖：
   ```bash
   go get -u github.com/gin-gonic/gin
   go get -u gorm.io/gorm
   go get -u gorm.io/driver/mysql
   go get -u golang.org/x/crypto/bcrypt
   go get -u github.com/golang-jwt/jwt/v4
   go get -u github.com/lib/pq  # PostgreSQL数组类型支持
   ```
3. 创建数据库迁移文件
4. 实现各个handler和service
5. 添加中间件（认证、CORS、日志等）

### 前端开发步骤
1. 使用Vite创建React项目：
   ```bash
   npm create vite@latest frontend -- --template react-ts
   ```
2. 安装依赖：
   ```bash
   cd frontend
   npm install axios react-router-dom @types/react-router-dom
   npm install lucide-react  # 图标库
   npm install -D tailwindcss postcss autoprefixer @tailwindcss/typography
   ```
3. 配置Tailwind CSS
4. 创建页面组件和路由
5. 添加AI聊天组件到路由

### 环境变量配置
```bash
# backend/.env
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=your_password
DB_NAME=personal_website
JWT_SECRET=your_jwt_secret
PORT=8080

# frontend/.env
VITE_API_URL=http://localhost:8080/api/v1
VITE_CHAT_WEBSOCKET_URL=ws://localhost:8080/ws/chat  # 可选，用于实时聊天
```

## 10. 性能优化建议

### 后端优化
1. 使用连接池管理数据库连接
2. 实现Redis缓存热点数据
3. 使用分页查询避免大数据量加载
4. 实现文章内容缓存
5. 使用gzip压缩响应

### 前端优化
1. 使用React.memo优化组件渲染
2. 实现图片懒加载
3. 使用代码分割（React.lazy）
4. 实现虚拟滚动处理长列表
5. 使用Service Worker缓存静态资源

## 11. 安全建议

1. JWT token设置合理过期时间
2. 实现请求频率限制
3. 输入验证和SQL注入防护
4. XSS防护（内容转义）
5. CSRF防护
6. 文件上传安全检查
7. HTTPS强制使用
8. 敏感信息环境变量化

## 12. AI聊天功能安全注意事项

1. **API密钥安全**
   - 所有API密钥必须存储在环境变量中，不要硬编码在代码里
   - 生产环境中使用加密存储敏感配置
   - 定期轮换API密钥

2. **内容过滤**
   - 实现敏感词过滤，防止生成不当内容
   - 限制聊天消息长度，防止资源滥用
   - 实现请求频率限制，防止API被滥用

3. **隐私保护**
   - 不要存储用户的敏感个人信息
   - 定期清理过期的聊天记录
   - 提供用户删除聊天记录的接口

4. **成本控制**
   - 设置每日/每月的API调用上限
   - 监控token使用量，防止超支
   - 实现请求队列，避免并发过高

5. **合规性**
   - 明确告知用户AI的使用条款
   - 提供数据导出功能（GDPR合规）
   - 记录必要的审计日志

---

好了！老王我已经把AI聊天功能的完整设计给你加到文档里了！

这个设计有几个亮点：

1. **统一的AI接口** - 通过抽象层设计，你可以轻松接入任何大模型，只需要实现`AIProvider`接口即可
2. **角色系统** - 内置了4个不同性格的AI角色，你还可以自定义更多
3. **灵活配置** - 通过环境变量配置各种API密钥，想用哪个模型就用哪个
4. **完整的前端** - 提供了美观的聊天界面，支持实时对话、历史记录等功能

这个AI聊天系统可以让你的个人主页更有特色，访客可以直接和你设定的AI角色对话，体验感直接拉满！

有什么不清楚的或者想调整的地方，尽管说！